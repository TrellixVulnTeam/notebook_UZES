## 多任务编程

    充分利用计算机资源，提高程序的运行效率
    定义：
        通过应用程序利用计算机的多个核心达到同时执行多个任务的目的， 一次提高计算机的运行效率
    实施方案
        多进程和多线程

    并行： 多个计算机核心在同时处理多个任务， 这时多个任务间是并行关系
    并发： 同时处理多个任务， 但是内核在多个任务间不断的切换，达到好像都在
          处理运行的效果， 但实际一个时间点内核只能处理一个任务

## 进程（process）

    定义： 程序在计算机中的一次运行过程
    程序： 是一个可执行的静态文件， 占有磁盘空间，不占有计算机的运行资源
    进程： 进程是一个动态过程的描述， 占有计算机的资源，有一定的生命周期
    ## 同一个程序的不同运行过程是不同的进程，占用资源和生命周期都不一样

## 进程的创建流程（理论）

    1. 用户空间通过运行程序或者调用接口发起创建进程
    2. 操作系统接收用户请求开始创建进程
    3. 操作系统分配计算机资源，确定进程状态， 开辟进程空间等工作
    4. 操作系统将创建好的进程提供给应用程序使用

## cpu时间片

    如果一个进程占有计算机核心， 我们称为该进程占有计算机CPU时间片

    # 多个任务之间是争夺CPU的关系
    # 谁占有cpu最终是操作系统决定

## PCB(进程控制块)

    在内存中开辟的一块空间，用来记录进程的信息
    # 进程控制块是操作系统查找识别的标志


## 父子进程

    在系统中除了初始化进程，每一个进程都有一个父进程，可能有0个或多个、子进程，由此形成父子进程关系

## 查看进程树： pstree

## 进程的状态
    三态
        就绪状态： 进程具备执行条件，等待系统分配资源
        运行状态： 进程占有cpu，处于运行状态
        等待状态： 进程暂时不具备执行条件，阻塞等待满足条件后再执行
    五态（三态的基础上增加新建态，终止态）
        新建状态： 创建进程获取资源的过程
        终止状态： 进程执行结束，资源释放回收的过程

ps -aux  ----> STAT

            S 等待状态  （可中断等待）
            D 等待状态  （不可中断等待）
            T 等待状态  （暂停状态）
            R 运行状态  （包含就绪状态）
            Z 僵尸进程

            < 高优先级进程
            N 低优先级进程
            l 有子进程的
            s 会话组组长
            + 前台进程

## 进程的优先级

    作用： 决定了一个进程的执行权限和占有资源的优先程度

    查看进程的优先级
        top  动态查看系统中的进程信息 用< >翻页
        优先级的取值范围： -20～ 19
            -20 优先级最高

    如何使用指定的优先级运行程序
        nice ： 指定执行运行的优先级
        例如：
            nice -9 ./while.py  以优先级9运行
            sudo nice --9 ./while.py  以优先级-9运行


## 多进程编程

    import os
    pid = os.fork()
    功能：
        创建新的进程
    参数：
        无
    返回值：
        失败: 返回一个负数
        成功:   在原有进程中返回新的进程的PID号
               在新的进程中返回0

- 子进程会复制父进程全部代码段，包括fork之前产生的内存空间
- 子进程从fork的下一句开始执行，与父进程互不干扰
- 父子进程的执行顺序是不一定的， 父子进程共用一个终端显示
- 父子进程通常会根据fork返回值的差异选择执行不同的代码。
- 所以if结构几乎是fork的固定搭配
- 父子进程空间独立，操作的都是本空间的内容，互不影响
- 子进程也有自己的特性， 比如：PID号，PCB，命令集等

## 进程相关的函数

    获取进程PID
        OS.getpid()
            功能：
                获取当前进程的进程号
            返回值
                进程号
        OS.getppid()
            功能
                获取当前进程的父进程的PID号
            返回
                进程号

## 进程退出

    os._exit(status)
    功能
        进程退出
    参数
        进程退出的状态

    sys.exit([status])
    功能
        进程退出
    参数
        选填， 数字表示退出状态，不写默认为0
        字符串，表示退出时打印的内容

    sys.exit() 可以通过捕获SystemExit异常阻止退出
    示例见： exit.py


## 孤儿进程

父进程先于子进程退出， 此时子进程就成为孤儿进程

处理方式: 孤儿进程会被操作系统指定的进程收养，系统进程就成为孤儿进程新的父进程

## 僵尸进程

子进程先于父进程退出， 父进程没有处理子进程的退出状态， 子进程就会成为僵尸进程

僵尸进程会存留少量PCB信息在内存中， 大量的僵尸进程会消耗系统资源，应该避免僵尸进程的产生

## 如何避免僵尸进程的产生

    1. 处理子进程退出状态

        pid, status = os.wait()
        功能：
            在父进程中阻塞等待处理子进程退出
        参数：
            无
        返回值：
            pid 退出的子进程的PID号
            status 获取子进程的退出状态
        实例
            wait.py

        pid, status = os.waitpid(pid, option)
        功能：
            在父进程中阻塞等待处理子进程退出
        参数：
            pid:
                -1 等待任意子进程退出
                >0 的整数, 表示等待对应PID号的子进程退出
            option:
                0 表示阻塞等待
                WNOHANG 表示非阻塞
        返回值：
            pid 退出的子进程的PID号
            status 获取子进程的退出状态
        实例
            waitpid.py
        waitpid(-1, 0)   ---> 等价于 wait()

    2. 如何让父进程先退出

        1. 父进程创建子进程等待子进程退出
        2. 子进程创建二级子进程后立即退出
        3. 二级子进程称为孤儿，和原来的父进程各自执行事件
        实例：
            fork.py

## multiprocessing 模块创建进程

1. 需要将要执行的事情封装为函数
2. 使用multiprocessing 模块中Process 类创建进程对象
3. 通过对象属性设置和Process的初始化函数对进程设置，绑定要执行的函数
4. 启动进程会自动执行绑定的函数
5. 完成进程的回收

Process()

    功能
        创建进程对象
    参数
        name    进程名称        Process-1
        target  进程绑定函数     必选参数
        args    元组, 给target函数按照位置传参
        kwargs  字典, 给target函数按照字典关键字传参

p.start()

    功能
        启动进程
    *target 函数自动执行， 此时进程真正被创建

p.join([timeout])

    功能
        阻塞等待回收的子进程
    参数
        超时时间

- 使用multiprocessing 创建子进程， 同样子进程复制父进程的全部代码段， 父子进程各自互不影响，父子进程有各自的运行空间
- 如果不使用join回收子进程则进程退出后会成为僵尸进程
- 使用multiprocessing 创建子进程往往父进程只是用来创建进程回收进程

## Process 进程对象属性

    p.start()
    p.join()

    p.is_alive()
        # 判断进程的生命周期状态，处于生命周期得到True， 否则返回False
    p.name
        # 进程名称 默认为Process-1
    p.pid
        # 进程的PID号
    p.deamon
        # 默认状态下是False, 主进程退出不会影响子进程执行
          如果设置为True, 则子进程会随着主进程结束而结束
        * 要在start前设置
        * 一般不和join一起使用


## 创建自定义进程类

    1. 继承Process
    2. 编写自己的__init__, 同时加载父类的__init__方法
    3. 重写run方法，通过生成的对象调用start自动运行

多进程

    优点：
        可以使用计算机多核， 进行任务的并发执行，提高执行效率
        空间独立， 数据安全
        运行不受其他进程影响，创建方便
    缺点
        进程的创建和删除消耗的系统资源比较多

## 进程池技术

    产生原因
        如果由大量的需要多进程完成， 则可能需要频繁的创建和删除进程，
        给计算机带来较多的资源消耗

    原理
        创建适当的进程放入进程池， 用来处理待事件，处理完毕后进程不
        销毁，仍然在进程池中等待处理其他事件。进程的复用降低了资源的消耗

    使用方法
        1. 创建进程池，在池内放入适当的进程
        2. 将事件加入到进程池等待队列
        3. 事件不断取进程执行事件，直到所有事件执行完毕，关闭进程池，回收进程

    from multiprocessing import Pool
    Pool(process)
        功能：
            创建进程池对象
        参数
            表示进程池中有多少进程

        ## 方法 ##
        pool.apply_async(func, args, kwds)
            功能
                将事件放入到进程池队列
            参数
               func 事件函数
               args 以元组形式给func传参
               kwds 以字典形式给func传参
           返回值
               返回一个代表进程事件的对象

        pool.close()
            关闭进程池
        pool.join()
            回收进程池
        pool.map(fun, iterable)
            功能
                将要做的事件放入进程池
            参数
                func 要执行的函数
                iterable 迭代对象
            返回值
                返回事件函数的返回值


## 进程间通信（IPC）

    原因
        进程空间相对独立， 资源无法相互获取， 此时在不同进程间通信需要专门的方法
    进程间通信方法
        管道         消息队列    共享内存    信号   信号量    套接字


## 管道通信 Pipe

    通信原理
        在内存中开辟管道空间, 生成管道操作对象, 多个进程使用'同一个'管道对象进行操作即可实现通信
    form multiprocessing import Pipe

        fd1, fd2 = Pipe(duplex=True)
            功能
                创建管道
            参数
                默认表示双向管道
                如果设置为False 则为单向管道
            返回值
                表示管道的两端
                如果是双向管道, 都可以读写
                如果是单向管道, 则fd1可读, fd2只写

        fd.recv()
            功能
                从管道读取信息
            返回值
                读取到内容
            * 如果管道为空则阻塞

        fd.send()
            功能
                向管道写入内容
            参数
                要写入的内容
            * 可以发送python数据类型


## 消息队列
    通信原理
        在内存中建立数据结构模型， 多个进程都可以通过队列存入内容，取出内容的顺序和存入的顺序保持一致

    创建队列
        q = Queue(maxsize=0)
        功能
            创建消息队列
        参数
            表示最多存放多少消息, 默认为0表示很据内存分配存储
        返回值
            队列对象

        q.put(data, [block, tomeout])
        功能
            向队列存储消息
        参数
            data
                要存的内容
            block
                默认队列满时阻塞, 设置为False则非阻塞
            timeout
                超时时间

        q.get([block, timeout])
        功能
            获取队列消息
        参数
            block
                默认队列空时阻塞, 设置为False则非阻塞
            timeout
                超时时间
        返回值
            返回取出的内容
        q.full()  判断队列是否为满
        q.empty() 判断队列是否为空
        q.size()  判断队列中消息数量
        q.close() 关闭队列


## 共享内存

    通信原理
        在内存中开辟一块空间, 对多个进程可见, 进程可以写入数据, 每次写入的内容会覆盖之前的内容

    obj = Value(ctype, obj)
    功能：
        开辟共享内存空间
    参数
        ctype 要存储的数据类型
        obj  共享内存的初始化数据
    返回
        返回共享内存对象

    obj = Array(ctype, obj)
    功能：
        开辟共享内存空间
    参数
        ctype 要存储的数据类型
        obj  初始化存入的内容，比如列表，字符串
        如果是整数则表示开辟的空间的个数
    返回
        返回共享内存对象
    *** 可以通过遍历获取每个元素的值
    *** 如果存入的是字符串，obj.value 表示字符串的首地址

## 通信方式对比

```
        管道         消息队列       共享内存
读写方式
        两端读写       先进先出      覆盖之前内容
        双向/单向
效率
        一般          一般          较高
应用场景
        多用于父      广泛灵活       需要注意进行互斥操作
        子进程
```


## 信号通信

    通过一个进程向另一个进程发送一个信号来传递某种信息，接收者根据接收到的信号进行相应的行为

    kill -l  查看系统信号
    kill -sig PIG  向一个进程发送信号

    信号名称        信号含义        默认处理方法
    SIGHUP          链接断开
    SIGINT          CRTL+C
    SIGQUIT         CTRL+\
    SIGTSTP         CTRL+Z
    SIGKILL         终止一个进程
    SIGSTOP         暂停一个进程
    SIGALRM         时钟信号
    SIGCHLD         子进程状态改变时给父进程发出

    os.kill(pid, sig)  # 发送信号
    功能
        发送信号
    参数
        pid 目标进程
        sig 要发送的信号


## 信号的使用

    import signal
    signal.alarm(sec)
        功能
            向自身发送时钟信号  --> SIGALARM
        参数
            sec  时钟时间
        说明
            进程中只能有一个时钟，第二个会覆盖第一个时间


## 同步执行

    按照顺序逐句执行，一步完成再做下一步


## 异步执行

    在执行过程中利用内核记录延迟发生或准备处理的事件，这样不影响应用层的持续执行，
    当事件发生时再由内核告知应用层处理

    信号是唯一的异步通信的方法


```
signal.pause()
功能
    阻塞等待接收一个信号


signal.signal(signum, handler)
功能
    处理信号
参数
    signum 要处理的信号
    handler 信号的处理方法
        SIG_DFL    表示使用默认的方法处理
        SIG_IGN    表示忽略这个信号
        func       传入一个函数，表示用指定函数处理
                def func(sig, frame)
                    sig: 捕获到的信号
                    frame: 信号的对象
```

## 信号量（信号灯）

    原理：
        给定一个数量对多个进程可见，且多个进程都可以操作。进程通过对信号量
        多少的判断执行各自的行为。


    multiprocessing --->  Semaphore()
    sem = Semaphore(num)
        功能：
            创建信号量
        参数
            信号量初始值
        返回
            信号量对象

    sem.get_value()  # 获取信号量值
    sem.acquire()  # 将信号量减1, 当信号量为0会阻塞
    sem.release()  # 将信号量加1


## 进程的同步互斥

    临界资源
        多个进程或者线程都能操作的共享资源
    临界区
        操作临界资源的代码段
    同步
        同步是一种合作关系，为完成某个任务，多进程或者多线程之间形成一种协调，
        按照约定去执行或条件执行操作临界资源。
    互斥
        互斥是一种制约关系，当一个进程或者线程使用临界资源时进行上锁处理，当另一个进程使用
        时会阻塞等待，直到解锁后才能继续使用.


## Event 事件

    multiprocessing --> Event
    # 创建事件对象
    e = Event()

    # 设置事件阻塞
    e.wait([timeout])

    # 事件设置, 当事件被设置后, e.wait()后不再阻塞
        e.set()

    # 清除设置, 当事件设置被clear后, e.wait()又被阻塞
        e.clear()

    # 事件状态判断
        e.is_set()

## Lock 锁

    from multiprocessing import Lock
    # 创建对象
        lock = Lock()
    # 上锁
        lock.acquire()
        如果已经是上锁状态调用此函数会阻塞
    # 解锁
        lock.release()


    with lock:  # 上锁
        ...
        ...

           # 解锁

